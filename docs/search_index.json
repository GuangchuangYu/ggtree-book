[
["short-introduction-to-r.html", "ggtree: Elegant Graphics for Phylogenetic Tree Visualization and Annotation Chapter 1 Short introduction to R", " ggtree: Elegant Graphics for Phylogenetic Tree Visualization and Annotation Guangchuang Yu Chapter 1 Short introduction to R say hello to R "],
["short-introduction-to-ggplot2.html", "Chapter 2 Short introduction to ggplot2", " Chapter 2 Short introduction to ggplot2 say hello to ggplot2 "],
["chapter-treeio.html", "Chapter 3 Parsing phylogenetic trees with associated data: treeio 3.1 Introduction 3.2 Methods and Materials 3.3 Results 3.4 Discussion", " Chapter 3 Parsing phylogenetic trees with associated data: treeio 3.1 Introduction Phylogenetic trees are commonly used to present evolutionary relationships of species including influenza virus. Information associated with taxon species/strains may be further analyzed in the context of the evolutionary history depicted by the phylogenetic tree. For example, host information of the influenza virus strains in the tree could be studied to understand the host range of a virus lineage (Parrish, Murcia, and Holmes 2015). Moreover, such meta-data (e.g., isolation host, time, location, etc.) directly associated with taxon strains are also often subjected to further evolutionary or comparative phylogenetic models and analyses, to infer their dynamics associated with the evolutionary or transmission processes of the virus. For examples, time and geographic information of the influenza virus strains could be used for estimating virus spread in temporal and spatial scales (Lam, Hon, and Tang 2010). All these meta-data are stored either as the annotation data associated with the nodes or branches, and are often produced in inconsistent format by different analysis programs. Therefore, the growth of analysis tools and models available introduces a challenge to integrate different varieties of data and analysis results from different sources for an integral analysis on the same phylogenetic tree background. This chapter describes the R package, treeio, developed in this thesis project to deal with this challenge. To begin with, the existing tree file formats and analysis output files are introduced. There are several file formats designed to store phylogenetic trees and the data associated with the nodes and branches. The three commonly used formats are Newick1, NEXUS (D. R. Maddison et al. 1997) and Phylip (Felsenstein 1989). Some formats (e.g., NHX) are extended from Newick format. Newick and NEXUS formats are supported as input by most of the software in evolutionary biology, while some of the software tools output newer standard files (e.g., BEAST and MrBayes) by introducing new rules/data blocks for storing evolutionary inferences. On the other cases (e.g., PAML and r8s), output log files are only recognized by their own single software. 3.1.1 Newick tree format The Newick tree format is the standard for representing trees in computer-readable form. Figure 3.1: A sample tree for demonstrating Newick text to encode tree structure. Tips were aligned to right hand side and branch lengths were labelled on the middle of each branch. The rooted tree shown in Figure 3.1 can be represented by the following sequence of characters as a newick tree text. (t5:0.89,((t4:0.59,t1:0.37):0.34,(t2:0.03,t3:0.67):0.9):0.04); The tree text ends with semicolon. Internal nodes are represented by a pair of matched parentheses. Between the parentheses are descendant nodes of that node. For instance (t4:0.59, t1:0.37) represents the parent node of t4 and t1 that are the immediate descendants. Sibling nodes are separated by comma and tips are represented by their names. A branch length (from parent node to child node) is represented by a real number after the child node and preceded by a colon. Singular data (e.g., bootstrap values) associated with internal nodes or branches maybe encoded as node label and represented by the simple text/numbers before the colon. Newick tree format was developed by Meacham in 1984 for the PHYLIP (Retief 2000) package. Newick format is now the most widely used tree format and used by PHYLIP, PAUP* (Wilgenbusch and Swofford 2003), TREE-PUZZLE (Schmidt et al. 2002), MrBayes and many other applications. Phylip tree format contains Phylip multiple sequence alignment (MSA) with a corresponding Newick tree text that was built based on the MSA sequences in the same file. 3.1.2 NEXUS tree format The NEXUS format incorporates Newick tree text with related information organized into separated units known as blocks. A NEXUS block has the following structure: #NEXUS ... BEGIN characters; ... END; For example, the above example tree can be saved as a following NEXUS format: #NEXUS [R-package APE, Wed Nov 9 11:46:32 2016] BEGIN TAXA; DIMENSIONS NTAX = 5; TAXLABELS t5 t4 t1 t2 t3 ; END; BEGIN TREES; TRANSLATE 1 t5, 2 t4, 3 t1, 4 t2, 5 t3 ; TREE * UNTITLED = [&amp;R] (1:0.89,((2:0.59,3:0.37):0.34, (4:0.03,5:0.67):0.9):0.04); END; Comments can be placed by using square brackets. Some blocks can be recognized by most of the programs including TAXA (contains information of taxa), DATA (contains data matrix, e.g., sequence alignment) and TREE (contains phylogenetic tree, i.e., Newick tree text). Notably, blocks can be very diversed and some of them are only be recognized by one particular program. For example NEXUS file exported by PAUP* has a paup block which contains PAUP* commands, whereas FigTree exports NEXUS file with a figtree block that contains visualization settings. NEXUS organizes different types of data into different blocks, whereas programs that support reading NEXUS can parse some blocks they recognized and ignore those they could not. This is a good mechanism to allow different programs to use the same format without crashing when unsupported types of data are present. Notably most of the programs only support parsing TAXA, DATA and TREE blocks, therefore a program/platform that could generically read all kinds of data blocks from the NEXUS would be useful for phylogenetic data integration. The DATA block is widely used to store sequence alignment. For this purpose, user can store tree and sequence data in Phylip format which are essentially Phylip multiple sequence alignment and Newick tree text respectively. It is used in Phylogeny Inference Package (PHYLIP). 3.1.3 New Hampshire eXtended format Newick, NEXUS and phylip are mainly designed to store phylogenetic tree and basic singular data associated with internal nodes or branches. In addition to the singular data annotation at branches and nodes (mentioned above), New Hampshire eXtended format (NHX), which is based on Newick (also called New Hampshire), was developed to introduce tags to associate multiple data fields with the tree nodes (both internal nodes and tips). Tags are placed after branch length and must be wrapped between [&amp;&amp;NHX and ] which makes it possible to compatible with NEXUS format as it defined characters between [ and ] as comments. NHX is also the output format of PHYLODOG (Boussau et al. 2013) and RevBayes (Höhna et al. 2016). A Tree Viewer (ATV) (Zmasek and Eddy 2001) is a java tool that supports displaying annotation data stored in NHX format, but this package is no more maintained. Here is a sample tree from NHX definition document2: (((ADH2:0.1[&amp;&amp;NHX:S=human], ADH1:0.11[&amp;&amp;NHX:S=human]): 0.05[&amp;&amp;NHX:S=primates:D=Y:B=100],ADHY: 0.1[&amp;&amp;NHX:S=nematode],ADHX: 0.12[&amp;&amp;NHX:S=insect]):0.1[&amp;&amp;NHX:S=metazoa:D=N], (ADH4:0.09[&amp;&amp;NHX:S=yeast],ADH3:0.13[&amp;&amp;NHX:S=yeast], ADH2:0.12[&amp;&amp;NHX:S=yeast],ADH1:0.11[&amp;&amp;NHX:S=yeast]): 0.1[&amp;&amp;NHX:S=Fungi])[&amp;&amp;NHX:D=N]; 3.1.4 Jplace format In order to store the NGS short reads mapped onto a phylogenetic tree (for the purpose of metagenomic classification; illustrated with more details in Chapter 5), Matsen proposed jplace format for such phylogenetic placements (Matsen et al. 2012). Jplace format is based on JSON and contains four keys: tree, fields, placements, metadata and version. The tree value contains tree text extended from Newick tree format by putting the edge label in brackets (if available) after branch length and putting the edge number in curly braces after edge label. The fields value contains header information of placement data. The value of placements is a list of pqueries. Each pquery contains two keys: p for placements and n for name or nm for names with multiplicity. The value of p is a list of placement for that pqueries. Here is a jplace sample file: { &quot;tree&quot;: &quot;(((((((A:4{1},B:4{2}):6{3},C:5{4}):8{5},D:6{6}): 3{7},E:21{8}):10{9},((F:4{10},G:12{11}):14{12},H:8{13}): 13{14}):13{15},((I:5{16},J:2{17}):30{18},(K:11{19}, L:11{20}):2{21}):17{22}):4{23},M:56{24});&quot;, &quot;placements&quot;: [ {&quot;p&quot;:[24, -61371.300778, 0.333344, 0.000003, 0.003887], &quot;n&quot;:[&quot;AA&quot;] }, {&quot;p&quot;:[[1, -61312.210786, 0.333335, 0.000001, 0.000003], [2, -61322.210823, 0.333322, 0.000003, 0.000003], [3, -61352.210823, 0.333322, 0.000961, 0.000003]], &quot;n&quot;:[&quot;BB&quot;] }, {&quot;p&quot;:[[8, -61312.229128, 0.200011, 0.000001, 0.000003], [9, -61322.229179, 0.200000, 0.000003, 0.000003], [10, -61342.229223, 0.199992, 0.000003, 0.000003]], &quot;n&quot;:[&quot;CC&quot;] } ], &quot;metadata&quot;: {&quot;info&quot;: &quot;a jplace sample file&quot;}, &quot;version&quot; : 2, &quot;fields&quot;: [&quot;edge_num&quot;, &quot;likelihood&quot;, &quot;like_weight_ratio&quot;, &quot;distal_length&quot;, &quot;pendant_length&quot; ] } Jplace is the output format of pplacer (Matsen, Kodner, and Armbrust 2010) and Evolutionary Placement Algorithm (EPA) (Berger, Krompass, and Stamatakis 2011). But these two programs do not contain tools to visualize placement results. Pplacer provides placeviz to convert jplace file to phyloXML or Newick formats which can be visualized by Archaeopteryx3. 3.1.5 Software outputs RAxML (Stamatakis 2014) can output Newick format by storing the bootstrap values as internal node labels. Another way that RAxML supported is to place bootstrap value inside square brackets and after branch length. This could not be supported by most of the software that support Newick format where square brackets will be ignored. BEAST (Bouckaert et al. 2014) output is based on NEXUS and it also introduce square brackets in the tree block to store evolutionary evidences inferred by BEAST. Inside brackets, curly braces may also incorporated if feature values have length more than 1 (e.g., HPD or range of substitution rate). These brackets are placed between node and branch length (i.e., after label if exists and before colon). Bracket is not defined in Newick format and is reserve character for NEXUS comment. So these information will be ignored for standard NEXUS parsers. Here is a sample TREE block of the BEAST output: tree TREE1 = [&amp;R] (((11[&amp;length=9.4]:9.38,14[&amp;length=6.4]: 6.385096430786298)[&amp;length=25.7]:25.43,4[&amp;length=9.1]: 8.821663252749829)[&amp;length=3.0]:3.10,(12[&amp;length=0.6]: 0.56,(10[&amp;length=1.6]:1.56,(7[&amp;length=5.2]:5.19, ((((2[&amp;length=3.3]:3.26,(1[&amp;length=1.3]:1.32, (6[&amp;length=0.8]:0.83,13[&amp;length=0.8]:0.8311577761397366) [&amp;length=2.4]:2.48917886025146)[&amp;length=0.9]: 0.9416178372674331)[&amp;length=0.4]:0.49,9[&amp;length=1.7]: 1.757288031101215)[&amp;length=2.4]:2.35,8[&amp;length=2.1]: 2.1125745387283246)[&amp;length=0.2]:0.23,(3[&amp;length=3.3]:3.31, (15[&amp;length=5.2]:5.27,5[&amp;length=3.2]:3.2710481368304585) [&amp;length=1.0]:1.0409443024626412)[&amp;length=1.9]: 2.0372962536780435)[&amp;length=2.8]:2.8446835614595685) [&amp;length=5.3]:5.367459711197171)[&amp;length=2.0]: 2.0037467863383043)[&amp;length=4.3]:4.360909907798238) [&amp;length=0.0]; BEAST output can contain many different evolutionary inferences, depending of the analysis models defined in BEAUTi for running. For example in molecular clock analysis, it contains rate, length, height, posterior and corresponding HPD and range for uncertainty estimation. Rate is the estimated evolutionary rate of the branch. Length is the length of the branch in years. Height is the time from node to root while posterior is the Bayesian clade credibility value. The above example is the output tree of clock analysis and should contains these inferences. To save space, I only keep the length above. MrBayes (J. P. Huelsenbeck and Ronquist 2001) is a program that uses Markov Chain Monte Carlo method to sample from the posterior probability distributions. Its output file annotates nodes and branches separately by two sets of square brackets. For example below, posterior clade probabilities for the node and branch length estimates for the branch: tree con_all_compat = [&amp;U] (8[&amp;prob=1.0]: 2.94e-1[&amp;length_mean=2.9e-1],10[&amp;prob=1.0]: 2.25e-1[&amp;length_mean=2.2e-1],((((1[&amp;prob=1.0]: 1.43e-1[&amp;length_mean=1.4e-1],2[&amp;prob=1.0]: 1.92e-1[&amp;length_mean=1.9e-1])[&amp;prob=1.0]: 1.24e-1[&amp;length_mean=1.2e-1],9[&amp;prob=1.0]: 2.27e-1[&amp;length_mean=2.2e-1])[&amp;prob=1.0]: 1.72e-1[&amp;length_mean=1.7e-1],12[&amp;prob=1.0]: 5.11e-1[&amp;length_mean=5.1e-1])[&amp;prob=1.0]: 1.76e-1[&amp;length_mean=1.7e-1],(((3[&amp;prob=1.0]: 5.46e-2[&amp;length_mean=5.4e-2],(6[&amp;prob=1.0]: 1.03e-2[&amp;length_mean=1.0e-2],7[&amp;prob=1.0]: 7.13e-3[&amp;length_mean=7.2e-3])[&amp;prob=1.0]: 6.93e-2[&amp;length_mean=6.9e-2])[&amp;prob=1.0]: 6.03e-2[&amp;length_mean=6.0e-2],(4[&amp;prob=1.0]: 6.27e-2[&amp;length_mean=6.2e-2],5[&amp;prob=1.0]: 6.31e-2[&amp;length_mean=6.3e-2])[&amp;prob=1.0]: 6.07e-2[&amp;length_mean=6.0e-2])[&amp;prob=1.0]: 1.80e-1[&amp;length_mean=1.8e-1],11[&amp;prob=1.0]: 2.37e-1[&amp;length_mean=2.3e-1])[&amp;prob=1.0]: 4.05e-1[&amp;length_mean=4.0e-1])[&amp;prob=1.0]:1.16e +000[&amp;length_mean=1.162699558201079e+000])[&amp;prob=1.0] [&amp;length_mean=0]; To save space, most of the inferences were removed and only contains prob for clade probability and length_mean for mean value of branch length. The full version of this file also contains prob_stddev, prob_range, prob(percent), prob+-sd for probability inferences and length_median, length_95%_HPD for every branch. The BEAST and MrBayes outputs are expected to be parsed without inferences (dropped as comments) by software that support NEXUS. FigTree supports parsing BEAST and MrBayes outputs with inferences that can be used to display or annotate on the tree. But from there extracting these data for further analysis is still challenging. HyPhy (Pond, Frost, and Muse 2005) could do a number of phylogenetic analysis, including ancestral sequence reconstruction. For ancestral sequence reconstruction, these sequences and the Newick tree text are stored in NEXUS format as the major analysis output. It did not completely follow the NEXUS definition and only put the ancestral node labels in TAXA instead of external node label. The MATRIX block contains sequence alignment of ancestral nodes which cannot be referred back to the tree stored in TREES block since it does not contains node labels. Here is the sample output (to save space, only the first 72bp of alignment are shown): #NEXUS [ Generated by HYPHY 2.0020110620beta(MP) for MacOS(Universal Binary) on Tue Dec 23 13:52:34 2014 ] BEGIN TAXA; DIMENSIONS NTAX = 13; TAXLABELS &#39;Node1&#39; &#39;Node2&#39; &#39;Node3&#39; &#39;Node4&#39; &#39;Node5&#39; &#39;Node12&#39; &#39;Node13&#39; &#39;Node15&#39; &#39;Node18&#39; &#39;Node20&#39; &#39;Node22&#39; &#39;Node24&#39; &#39;Node26&#39; ; END; BEGIN CHARACTERS; DIMENSIONS NCHAR = 2148; FORMAT DATATYPE = DNA GAP=- MISSING=? NOLABELS ; MATRIX ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATTGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAATGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT ATGGAAGACTTTGTGCGACAGTGCTTCAATCCAATGATCGTCGAGCTTGCGGAAAAGGCAATGAAAGAATAT END; BEGIN TREES; TREE tree = (K,N,(D,(L,(J,(G,((C,(E,O)),(H,(I,(B,(A,(F,M))))))))))); END; There are other applications that output rich information text that also contains phylogenetic trees with associated data. For example r8s (Sanderson 2003) output three trees in its log file, namely TREE, RATE and PHYLO for branches scaled by time, substitution rate, and absolute substitutions respectively. Phylogenetic Analysis by Maximum Likelihood (PAML) (Z. Yang 2007) is a package of programs for phylogenetic analyses of DNA or protein sequences. Two main programs, BaseML and CodeML, implement a variety of models. BaseML estimates tree topology, branch lengths and substitution parameters using a number of nucleotide substitution models available, including JC69, K80, F81, F84, HKY85, T92, TN93 and GTR. CodeML estimates synonymous and non-synonymous substitution rates, likelihood ratio test of positive selection under codon substitution models (Goldman and Yang 1994). BaseML outputs mlb file that contains input sequence (taxa) alignment and phylogenetic tree with branch length as well as substitution model and other parameters estimated. The supplementary result file, rst, contains sequence alignment (with ancestral sequence if perform reconstruction of ancestral sequences) and Naive Empirical Bayes (NBE) probabilities that each site in the alignment evolved. CodeML outputs mlc file that contains tree structure and estimation of synonymous and non-synonymous substitution rates. CodeML also output supplementary result file, rst, that is similar to BaseML except that site is defined as codon instead of nucleotide. Parsing these files can be tedious and would oftentimes need a number of post-processing steps and require expertise in programming (e.g. with Python4 or Perl5). Introducing square brackets is quite common for storing extra information, including RAxML to store bootstrap value, NHX format for annotation, jplace for edge label and BEAST for evolutionary estimation, etc.. But the positions to place square brackets are not consistent in different software and the contents employ different rules for storing associated data, these properties make it difficult to parse associated data. For most of the software, they will just ignore square brackets and only parse the tree structure if the file is compatible. Some of them contains invalid characters (e.g. curly braces in tree field of jplace format) and even the tree structure can’t be parsed by standard parsers. It is difficult to extract useful phylogeny/taxon-related information from the different analysis outputs produced by various evolutionary inference software, for displaying on the same phylogenetic tree and for further analysis. FigTree supports BEAST output, but not for most of other software outputs that contains evolutionary inferences or associated data. For those output rich text files (e.g. r8s, PAML, etc.), the tree structure cannot be parsed by any tree viewing software and users need expertise to manually extract the phylogenetic tree and other useful result data from the output file. However, such manual operation is slow and error-prone, which is not practical for big-data. It was not easy to retrieve phylogenetic trees with evolutionary data from different analysis outputs of commonly used software in the field. Some of them (e.g., PAML output and jplace file) without software or programming library to support parsing file, while others (e.g., BEAST and MrBayes output) can be parsed without evolutionary inferences as they are stored in square brackets that will be omitted as comment by most of the software. Although FigTree support visualizing evolutionary statistics inferred by BEAST and MrBayes, extracting these data for further analysis is not supported. Different software packages implement different algorithms for different analyses (e.g., PAML for dN/dS, HyPhy for ancestral sequences and BEAST for skyline analysis). Therefore, in encountering the big genomic sequence data, there is a desire need to efficiently and flexibly integrate different analysis inference results for comprehensive understanding, comparison and further analysis. This motivated us to develop the programming library to parse the phylogenetic trees and data from various sources. 3.2 Methods and Materials To fill the gap that most of the tree formats or software outputs cannot be parsed within the same software/platform, an R package treeio was developed for parsing various tree file formats and outputs from common evolutionary analysis software. Treeio is developed with the R programming language (R Core Team 2016). Not only the tree structure can be parsed but also the associated data and evolutionary inferences, including NHX annotation, clock rate inferences (from BEAST and r8s programs), synonymous and non-synonymous substitutions (from CodeML), and ancestral sequence construction (from HyPhy, BaseML or CodeML), etc.. Currently, treeio is able to read the following file formats storing phylogenetic trees: Newick, NEXUS, New Hampshire eXtended format (NHX), jplace and Phylip as well as the data outputs from the following analysis programs: BEAST, EPA, HyPhy, MrBayes, PHYLODOG, phyloT, pplacer, r8s, RAxML and RevBayes. This is made possible with the several parser functions developed in treeio (Table 3.1). After parsing, storage of the tree structure with associated data is made through a set of S4 classes defined in the treeio package (Table 3.2). The overview of these S4 classes and the corresponding parser functions are illustrated in Figure 3.2. These parsed data are mapped to the tree branches and nodes inside these S4 objects, so that they can be efficiently used to visually annotate the tree using ggtree package we developed later (described in Chapter 3). Treeio also provides functions to merge these phylogeny-associated data for comparison and further analysis (more details in section 2.3.3). A programmable platform for phylogenetic data parsing, integration and annotations as such makes us easier to identify the evolutionary dynamics and correlation patterns. Table 3.1: Parser functions defined in treeio. Parser function Description read.beast parsing output of BEAST read.codeml parsing output of CodeML (rst and mlc files) read.codeml_mlc parsing mlc file (output of CodeML) read.hyphy parsing output of HYPHY read.jplace parsing jplace file including output of EPA and pplacer read.nhx parsing NHX file including output of PHYLODOG and RevBayes read.paml_rst parsing rst file (output of BaseML or CodeML) read.phylip parsing phylip file read.phyloT parsing output of phyloT (http://phylot.biobyte.de/) read.r8s parsing output of r8s read.raxml parsing output of RAxML Table 3.2: S4 classes defined in treeio. S4 Class Description beast storing output of read.beast() codeml storing output of read.codeml() codeml_mlc storing output of read.codeml_mlc() hyphy storing output of read.hyphy() jplace storing output of read.jplace() paml_rst for rst file obtained by PAML, including BaseML and CodeML phangorn storing ancestral sequences inferred by R package phangorn r8s storing output of read.r8s() treedata storing tree with associated data Figure 3.2: Overview of S4 classes and corresponding parser functions. Phylogenetic tree, branch/node-associated data and other information contained in the standard tree files or output files from supported analysis programs can be imported into a S4 tree object by parser functions. The middle and bottom compartments of the class diagrams (boxes) show the attributes to be added to the tree object after parsing and other helper methods, respectively. Multiple S4 tree objects can be merged into one using merge_tree function. 3.3 Results 3.3.1 Features of treeio The treeio package defined S4 classes for storing phylogenetic tree with diverse types of associated data or covariates from different sources including analysis outputs from different software packages (see Table 3.2). It also defined corresponding parser functions for parsing phylogenetic tree with annotation data and stored as data object in R for further manipulation or analysis (see Table 3.1). Several accessor functions were defined to facilitate accessing the tree annotation data, including get.fields for obtaining annotation features available in the tree object, get.placements for obtaining the phylogenetic placement results (i.e., output of pplacer, EPA, etc.), get.subs for obtaining the genetic substitutions from parent node to child node, and get.tipseq for getting the tip sequences. The S3 class, phylo, which was defined in ape (Paradis, Claude, and Strimmer 2004) package, is widely used in R community and many packages. As treeio uses S4 class, to enable those available R packages to analyze the tree imported by treeio, treeio provides as.phylo function to convert treeio-generated tree object to phylo object that only contains tree structure without annotation data. In the other way, treeio also provides as.treedata function to convert phylo object with evolutionary analysis result (e.g., bootstrap values calculated by ape or ancestral states inferred by phangorn (Schliep 2011)) to be stored as a treedata S4 object, making it easy to map the data to the tree structure and to be visualized using ggtree (introduced in Chapter 3). To allow integration of different kinds of data in phylogenetic tree, treeio provides merge_tree function (details in section 2.3.3) for combining evolutionary statistics/evidences imported from different sources including those common tree files and outputs from analysis programs (Table 3.1). There are other information, such as sampling location, taxonomy information, experimental result and evolutionary traits, etc. that are stored in separate files with user-defined format. In treeio, we could read in these data from the users’ files using standard R IO functions, and attach them to the tree object by the operator, %&lt;+%, defined in our treeio package. After attaching, the data will become the attributes associated with nodes or branches, which can be compared with other data incorporated, or can be visually displayed on the tree. To facilitate storing the merged data into a single file, treeio implemented write.jplace function to export tree object to a jplace file that has a robust format for storing complex data associated with the phylogenetic tree. The jplace file can be parsed and imported into R by our read.jplace function for future use. A full list of functions that defined in treeio can be found in Table ??. 3.3.2 Functions demonstrated 3.3.2.1 Parsing BEAST output file &lt;- system.file(&quot;extdata/BEAST&quot;, &quot;beast_mcc.tree&quot;, package=&quot;treeio&quot;) beast &lt;- read.beast(file) beast ## &#39;beast&#39; S4 object that stored information of ## &#39;/Library/R/library/treeio/extdata/BEAST/beast_mcc.tree&#39;. ## ## ...@ tree: ## Phylogenetic tree with 15 tips and 14 internal nodes. ## ## Tip labels: ## A_1995, B_1996, C_1995, D_1987, E_1996, F_1997, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;height&#39;, &#39;height_0.95_HPD&#39;, &#39;height_median&#39;, ## &#39;height_range&#39;, &#39;length&#39;, &#39;length_0.95_HPD&#39;, ## &#39;length_median&#39;, &#39;length_range&#39;, &#39;posterior&#39;, &#39;rate&#39;, ## &#39;rate_0.95_HPD&#39;, &#39;rate_median&#39;, &#39;rate_range&#39;. Not only tree structure but also all the features inferred by BEAST will be stored in the S4 object. These features can be used for tree annotation (Figure 4.12). The get.fields method return all available features. 3.3.2.2 Parsing PAML output The read.paml_rst function can parse the rst file from BaseML and CodeML. The only difference is the space in the sequences. For BaseML, each ten bases are separated by one space, while for CodeML, each three bases (triplet) are separated by one space. brstfile &lt;- system.file(&quot;extdata/PAML_Baseml&quot;, &quot;rst&quot;, package=&quot;treeio&quot;) brst &lt;- read.paml_rst(brstfile) get.fields(brst) ## [1] &quot;marginal_subs&quot; &quot;joint_subs&quot; &quot;marginal_AA_subs&quot; ## [4] &quot;joint_AA_subs&quot; Similarly, we can parse the rst file from CodeML. crstfile &lt;- system.file(&quot;extdata/PAML_Codeml&quot;, &quot;rst&quot;, package=&quot;treeio&quot;) crst &lt;- read.paml_rst(crstfile) get.fields(crst) ## [1] &quot;marginal_subs&quot; &quot;joint_subs&quot; &quot;marginal_AA_subs&quot; ## [4] &quot;joint_AA_subs&quot; Ancestral sequences inferred by BaseML or CodeML via marginal and joint ML reconstruction methods, as described in session 1.1.2, will be stored in the S4 object and mapped to tree nodes. The treeio will automatically determine the substitutions between the sequences at the both ends of each branch. Amino acid substitution will also be determined by translating nucleotide sequences to amino acid sequences. The computed substitutions will also be explicitly stored in the S4 object for efficient tree annotation later (Figure 4.14). CodeML infers selection pressure (see also session 1.1.4) and estimates dN, dS and dN/dS. These information are stored in output file mlc, which can be parsed by read.codeml_mlc function. mlcfile &lt;- system.file(&quot;extdata/PAML_Codeml&quot;, &quot;mlc&quot;, package=&quot;treeio&quot;) mlc &lt;- read.codeml_mlc(mlcfile) get.fields(mlc) ## [1] &quot;t&quot; &quot;N&quot; &quot;S&quot; &quot;dN_vs_dS&quot; &quot;dN&quot; ## [6] &quot;dS&quot; &quot;N_x_dN&quot; &quot;S_x_dS&quot; In previous sessions, we separately parsed rst and mlc files. However, we can also parse them altogether using read.codeml function: ml &lt;- read.codeml(crstfile, mlcfile) ml ## &#39;codeml&#39; S4 object that stored information of ## &#39;/Library/R/library/treeio/extdata/PAML_Codeml/rst&#39; and ## &#39;/Library/R/library/treeio/extdata/PAML_Codeml/mlc&#39;. ## ## ...@ tree: ## Phylogenetic tree with 15 tips and 13 internal nodes. ## ## Tip labels: ## A, B, C, D, E, F, ... ## Node labels: ## 16, 17, 18, 19, 20, 21, ... ## ## Unrooted; includes branch lengths. ## ## with the following features available: ## &#39;marginal_subs&#39;, &#39;joint_subs&#39;, &#39;marginal_AA_subs&#39;, ## &#39;joint_AA_subs&#39;, &#39;t&#39;, &#39;N&#39;, &#39;S&#39;, &#39;dN_vs_dS&#39;, &#39;dN&#39;, &#39;dS&#39;, ## &#39;N_x_dN&#39;, &#39;S_x_dS&#39;. All the feature data in both rst and mlc files were imported into a single S4 object and hence are available for further annotation and visualization. For example, we can annotate and display both dN/dS (from mlc file) and amino acid substitutions (from rst file) on the same phylogenetic tree (see Figure 4.14 in Chapter 3). 3.3.2.3 Parsing output of RAxML bootstraping analysis RAxML bootstraping analysis output a Newick tree text that is not standard as it stores bootstrap values inside square brackets after branch lengths. This file usually cannot be parsed by traditional Newick parser. The function read.raxml can read such file and stored the bootstrap as an additional features, which can be used to display on the tree or used to color tree branches, etc.. raxml_file &lt;- system.file(&quot;extdata/RAxML/&quot;, &quot;RAxML_bipartitionsBranchLabels.H3&quot;, package=&quot;treeio&quot;) raxml &lt;- read.raxml(raxml_file) get.fields((raxml)) ## [1] &quot;bootstrap&quot; 3.3.2.4 Parsing Phylip tree Phylip format contains multiple sequence alignment of taxa in Phylip sequence format with corresponding Newick tree text that was built from taxon sequences. Sequence alignment can be sorted based on the tree structure and displayed at the right hand side of the tree6. require(treeio) phyfile &lt;- system.file(&quot;extdata&quot;, &quot;sample.phy&quot;, package=&quot;treeio&quot;) phylip &lt;- read.phylip(phyfile) phylip ## &#39;phylip&#39; S4 object that stored information of ## &#39;/Library/R/library/treeio/extdata/sample.phy&#39;. ## ## ...@ tree: ## Phylogenetic tree with 15 tips and 13 internal nodes. ## ## Tip labels: ## K, N, D, L, J, G, ... ## ## Unrooted; no branch lengths. ## ## with sequence alignment available (15 sequences of length 2148) 3.3.2.5 Parsing HyPhy output Ancestral sequences inferred by HyPhy are stored in the NEXUS output file, which contains the tree topology and ancestral sequences. To parse this data file, users shall also provide an internal-node-labelled tree and tip sequences. After parsing these files, treeio will automatically infer the genetic substitutions by comparing the parent nodes to child nodes. nwk &lt;- system.file(&quot;extdata/HYPHY&quot;, &quot;labelledtree.tree&quot;, package=&quot;treeio&quot;) ancseq &lt;- system.file(&quot;extdata/HYPHY&quot;, &quot;ancseq.nex&quot;, package=&quot;treeio&quot;) tipfas &lt;- system.file(&quot;extdata&quot;, &quot;pa.fas&quot;, package=&quot;treeio&quot;) hy &lt;- read.hyphy(nwk, ancseq, tipfas) get.fields(hy) ## [1] &quot;subs&quot; &quot;AA_subs&quot; 3.3.2.6 Parsing r8s output r8s uses parametric, semiparametric and nonparametric methods to relax molecular clock to allow better estimations of divergence times and evolution rates (Sanderson 2003). It outputs three trees in log file, namely TREE, RATO and PHYLO for time tree, rate tree and absolute substitution tree respectively. Time tree is scaled by divergence time, rate tree is scaled by substitution rate and absolute substitution tree is scaled by absolute number of substitution. After parsing the file, all these three trees are stored in one single tree object and can be visualized separately or simultaneously using ggtree. r8s &lt;- read.r8s(system.file(&quot;extdata/r8s/H3_r8s_output.log&quot;, package=&quot;treeio&quot;)) get.fields(r8s) ## [1] &quot;TREE&quot; &quot;RATO&quot; &quot;PHYLO&quot; 3.3.2.7 Parsing NHX tree New Hampshire eXtended format is an extension of Newick by introducing NHX tags. NHX is commonly used in phylogenetic software (including PHYLDOG and RevBayes) for storing statistical inferences. The following codes imported a NHX tree with three associated data, S (species), D (duplication event) and B (bootstrap value). The file content was presented in session 2.1.3 and associated data can be used to annotate the tree as illustrated in Figure 4.4. nhxfile &lt;- system.file(&quot;extdata/NHX&quot;, &quot;ADH.nhx&quot;, package=&quot;treeio&quot;) nhx &lt;- read.nhx(nhxfile) nhx ## &#39;treedata&#39; S4 object that stored information of ## &#39;/Library/R/library/treeio/extdata/NHX/ADH.nhx&#39;. ## ## ...@ tree: ## Phylogenetic tree with 8 tips and 4 internal nodes. ## ## Tip labels: ## ADH2, ADH1, ADHY, ADHX, ADH4, ADH3, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;S&#39;, &#39;D&#39;, &#39;B&#39;. 3.3.2.8 Parsing EPA and pplacer outputs EPA and pplacer have common output file format, jplace, which can be parsed by read.jplace() function. jpf &lt;- system.file(&quot;extdata/sample.jplace&quot;, package=&quot;treeio&quot;) jp &lt;- read.jplace(jpf) print(jp) ## &#39;jplace&#39; S4 object that stored information of ## &#39;/Library/R/library/treeio/extdata/sample.jplace&#39;. ## ## ...@ tree: ## Phylogenetic tree with 13 tips and 12 internal nodes. ## ## Tip labels: ## A, B, C, D, E, F, ... ## ## Rooted; includes branch lengths. ## ## with the following features available: ## &#39;edge_num&#39;, &#39;likelihood&#39;, &#39;like_weight_ratio&#39;, ## &#39;distal_length&#39;, &#39;pendant_length&#39;. In ggtree (Chapter 3), we provide get.placements method to access the placement. Thus, we may, for example, count the number of placement and annotate this information in the tree (e.g., scaled branch color or size). ## get only best hit get.placements(jp, by=&quot;best&quot;) ## name edge_num likelihood like_weight_ratio distal_length ## 1 AA 24 -61371.30 0.333344 3e-06 ## 2 BB 1 -61312.21 0.333335 1e-06 ## 3 CC 8 -61312.23 0.200011 1e-06 ## pendant_length ## 1 0.003887 ## 2 0.000003 ## 3 0.000003 ## get all placement get.placements(jp, by=&quot;all&quot;) ## name edge_num likelihood like_weight_ratio distal_length ## 1 AA 24 -61371.30 0.333344 0.000003 ## 2 BB 1 -61312.21 0.333335 0.000001 ## 3 BB 2 -61322.21 0.333322 0.000003 ## 4 BB 550 -61352.21 0.333322 0.000961 ## 5 CC 8 -61312.23 0.200011 0.000001 ## 6 CC 9 -61322.23 0.200000 0.000003 ## 7 CC 10 -61342.23 0.199992 0.000003 ## pendant_length ## 1 0.003887 ## 2 0.000003 ## 3 0.000003 ## 4 0.000003 ## 5 0.000003 ## 6 0.000003 ## 7 0.000003 The above example is demonstrated with a tiny sample file. In reality, EPA and pplacer may place thousands of short reads on a reference tree to taxonomically classify the sequencing reads. Therefore, the programmable parsing functions provided by treeio may facilitate the application of such phylogenetics-based methods in big-data genomic research. And, indeed these treeio functions are used in developing our new phylogeny-guided genome assembly method (Chapter 5). 3.3.3 Data integration and comparison The treeio serves as an infrastructure that enables various types of phylogenetic data inferred from common analysis programs to be imported and used in R. For instance dN/dS or ancestral sequences estimated by CodeML, short read placement inferred by EPA/pplacer and clade support values (posterior probabilities) inferred by BEAST/MrBayes. Treeio brings these external phylogenetic data to the R community and makes it available for further analysis in R. Furthermore, treeio can combine multiple phylogenetic trees together into one with their node/branch-specific attribute data. Essentially, as a result, one such attribute (e.g., substitution rate) can be mapped to another attribute (e.g., dN/dS) of the same node/branch for comparison and further computations. A previously published data set, seventy-six H3 hemagglutinin gene sequences of a lineage containing swine and human influenza A viruses (Liang et al. 2014), was used here to demonstrate the utilities of comparing evolutionary statistics inferred by different software. The dataset was re-analyzed by BEAST for timescale estimation and CodeML for synonymous and non-synonymous substitutions estimation. In this example, we first parsed the outputs from BEAST using read.beast and from CodeML using read.codeml into two S4 objects. Then the two objects containing separate sets of node/branch-specific data were merged via the merge_tree function. library(treeio) library(ggtree) beast_file &lt;- system.file(&quot;examples/MCC_FluA_H3.tree&quot;, package=&quot;ggtree&quot;) rst_file &lt;- system.file(&quot;examples/rst&quot;, package=&quot;ggtree&quot;) mlc_file &lt;- system.file(&quot;examples/mlc&quot;, package=&quot;ggtree&quot;) beast_tree &lt;- read.beast(beast_file) codeml_tree &lt;- read.codeml(rst_file, mlc_file) merged_tree &lt;- merge_tree(beast_tree, codeml_tree) get.fields(merged_tree) ## [1] &quot;height&quot; &quot;height_0.95_HPD&quot; ## [3] &quot;height_median&quot; &quot;height_range&quot; ## [5] &quot;length&quot; &quot;length_0.95_HPD&quot; ## [7] &quot;length_median&quot; &quot;length_range&quot; ## [9] &quot;posterior&quot; &quot;rate&quot; ## [11] &quot;rate_0.95_HPD&quot; &quot;rate_median&quot; ## [13] &quot;rate_range&quot; &quot;t&quot; ## [15] &quot;N&quot; &quot;S&quot; ## [17] &quot;dN_vs_dS&quot; &quot;dN&quot; ## [19] &quot;dS&quot; &quot;N_x_dN&quot; ## [21] &quot;S_x_dS&quot; &quot;marginal_subs&quot; ## [23] &quot;joint_subs&quot; &quot;marginal_AA_subs&quot; ## [25] &quot;joint_AA_subs&quot; After merging the beast_tree and codeml_tree objects, all node/branch-specific data imported from BEAST and CodeML output files are all available in the merged_tree object. The tree object was converted to data frame and visualized as hexbin scatterplot of dN/dS, dN and dS inferred by CodeML versus rate (substitution rate in unit of substitutions/site/year) inferred by BEAST on the same branches. library(dplyr) df &lt;- fortify(merged_tree) %&gt;% select(dN_vs_dS, dN, dS, rate) %&gt;% subset(dN_vs_dS &gt;=0 &amp; dN_vs_dS &lt;= 1.5) %&gt;% tidyr::gather(type, value, dN_vs_dS:dS) df$type[df$type == &#39;dN_vs_dS&#39;] &lt;- &#39;dN/dS&#39; df$type &lt;- factor(df$type, levels=c(&quot;dN/dS&quot;, &quot;dN&quot;, &quot;dS&quot;)) ggplot(df, aes(rate, value)) + geom_hex() + facet_wrap(~type, scale=&#39;free_y&#39;) Figure 3.3: Correlation of dN/dS, dN and dS versus substitution rate. After merging the BEAST and CodeML outputs, the branch-specific estimates (substitution rate, dN/dS , dN and dS) from the two analysis programs are compared on the same branch basis. The associations of dN/dS, dN and dS vs. rate are visualized in hexbin scatter plots. The output is illustrated in Fig. 3.3. We can then test the association of these node/branch-specific data using Pearson correlation, which in this case showed that dN and dS, but not dN/dS are significantly (p-values) associated with rate. After merging, all data inferred from different tools can be used to annotate the tree in ggtree (Chapter 3). The following example turned the merged_tree into a graphic object with tree branches colored by branches-specific substitution rates (rate) as shown in Fig. 3.4A. ggtree(merged_tree, aes(color=rate)) + theme_tree2() + scale_color_continuous(high=&#39;#D55E00&#39;, low=&#39;#0072B2&#39;) + geom_tiplab(size=2) The ggtree allows users to easily rescale a tree branches with another numerical variable. Here the tree branch lengths were rescaled and colored by dN inferred by CodeML as demonstrated in Fig. 3.4B. ggtree(merged_tree, branch.length=&#39;dN&#39;, aes(color=dN)) + scale_color_continuous(high=&#39;#D55E00&#39;, low=&#39;#0072B2&#39;) + theme_tree2() + geom_tiplab(size=2) Figure 3.4: Re-scaling tree branches. The tree with branches scaled in time (year from the root) and colored by substitution rates (A). The tree was re-scaled using dN as branch lengths and colored by dN values (B). As demonstrated above, phylogenetic data inferred from different analysis programs can be imported and used to annotate the tree (e.g., color branches or rescale branch lengths, etc.). These data can also be merged for joint analysis (Figure 3.3). They can be displayed on the same tree structure as more complex annotation to help visually inspection of their evolutionary patterns. In this example, we used dN/dS inferred by CodeML to color the tree and annotate the tree with posterior inferred by BEAST. Another example of annotating tree with diverse associated data were presented in Figure 4.18. ggtree(merged_tree, aes(color=dN_vs_dS), mrsd=&quot;2013-01-01&quot;, ndigits = 2) + geom_text2(aes(label=posterior), hjust=-.1, size=2, color=&quot;black&quot;) + scale_color_continuous(name=&#39;dN/dS&#39;, limits=c(0, 1.5), oob=scales::squish, low=&quot;green&quot;, high=&quot;red&quot;)+ theme_tree2(legend.position=c(.1, .8)) Figure 3.5: Time-scaled tree colored by dN/dS. The tree branches were scaled in time (Gregorian calendar) and colored by dN/dS. Clade posterior was displayed on the most recent common ancestor. Details of annotating phylogenetic tree with covariates and other associated data will be introduced in Chapter 3. 3.4 Discussion Software tools for inferring molecular evolution (e.g., ancestral states, molecular dating and selection pressure, etc.) are proliferating, but there is no single data format that is used by all different programs and capable to store different types of phylogenetic data. Most of the software packages have their own unique output formats and these formats are not compatible with each other. Parsing software outputs is challenging, which restricts the joint analysis using different tools. The treeio provides a set of functions (Table 3.1) for parsing various types of phylogenetic data files. These phylogenetic data can be integrated together that allows further exploration and comparison. Until now, most software tools in field of molecular evolution are isolated and often not fully compatible with each other for input and output files. All these software tools are designed to do their own analysis and the outputs are often not readable in other software. There is no software tool that was particularly designed to unify the inference data from different analysis programs. An efficient incorporation of the different inference data can compare and verify between methods, and comprehend the understanding of the study target at different aspects and angles, which may discover new systematic patterns and bring new insights to generate new hypothesis. As phylogenetic trees are growing in its application to identify patterns in evolutionary context, more different disciplines are employing phylogenetic trees in their research. For example, spatial ecologists may map the geographical positions of the organisms to their phylogenetic trees to understand the biogeography of the species (Schön et al. 2015); disease epidemiologists may incorporate the pathogen sampling time and locations into the phylogenetic analysis to infer the disease transmission dynamics in spatiotemporal space (Y.-Q. He et al. 2013); microbiologists may determine the pathogenicity of different pathogen strains and map them into their phylogenetic trees to identify the genetic determinants of the pathogenicity (Bosi et al. 2016); genomic scientists may use the phylogenetic trees to help taxonomically classify their metagenomic sequence data (Gupta and Sharma 2015). A robust tool such as treeio to import and map different types of data into the phylogenetic tree are important to facilitate these phylogenetics-related research, or a.k.a ‘phylodynamics’. Such tool could also help integrate different metadata (time, geography, genotype, epidemiological information) and analysis results (selective pressure, evolutionary rates) at the highest level and provide a comprehensive understanding of the study organisms. In the field of influenza research, there have been such attemps of studying phylodynamics of the influenza virus by mapping different meta-data and analysis results on the same phylogenetic tree and evolutionary time scale (Lam et al. 2015). Future development will extend treeio to support more file formats (e.g. NeXML and NeXSON) and develop more exporter functions to output trees with their associated data. The treeio package will be served as a platform for tree-related data integration. Currently, merge_tree function only support combining tree data from tree objects that have identical topology. Future development will extend it to support trees with topologies are not strictly the same by implementing consensus tree methods. References "],
["chapter-ggtree.html", "Chapter 4 Visualization and annotation of phylogenetic trees: ggtree 4.1 Introduction 4.2 Methods and Materials 4.3 Results 4.4 Discussion", " Chapter 4 Visualization and annotation of phylogenetic trees: ggtree 4.1 Introduction There are many software packages and webtools that are designed for displaying phylogenetic trees, such as TreeView (Page 2002), FigTree7, TreeDyn (Chevenet et al. 2006), Dendroscope (Huson and Scornavacca 2012), EvolView (Z. He et al. 2016) and iTOL (Letunic and Bork 2007), etc.. Only several of them, such as FigTree, TreeDyn and iTOL, allow users to annotate the trees with coloring branches, highlighted clades and tree features. However, their pre-defined annotating functions are usually limited to some specific phylogenetic data. As phylogenetic trees become more widely used in multidisciplinary studies, there is an increasing need to incorporate various types of the phylogenetic covariates and other associated data from different sources into the trees for visualizations and further analyses. For instance, influenza virus has a wide host range, diverse and dynamic genotypes and characteristic transmission behaviors that are mostly associated with the virus evolution and essentially among themselves. Therefore, in addition to standalone applications that focus on each of the specific analysis and data type, researchers studying molecular evolution need a robust and programmable platform that allows the high levels integration and visualization of many of these different aspects of data (raw or from other primary analyses) over the phylogenetic trees to identify their associations and patterns. To fill this gap, we developed ggtree, a package for the R programming language (R Core Team 2016) released under the Bioconductor project (Gentleman et al. 2004). The ggtree is built to work with phylogenetic data object generated by treeio, and display tree graphics with ggplot2 package (Wickham 2016) that was based on the grammar of graphics (Wilkinson et al. 2005). The R language is increasingly being used in phylogenetics. However, a comprehensive package, designed for viewing and annotating phylogenetic trees, particularly with complex data integration, is not yet available. Most of the R packages in phylogenetics focus on specific statistical analyses rather than viewing and annotating the trees with more generalized phylogeny-associated data. Some packages, including ape (Paradis, Claude, and Strimmer 2004) and phytools (Revell 2012), which are capable of displaying and annotating trees, are developed using the base graphics system of R. In particular, ape is one of the fundamental package for phylogenetic analysis and data processing. However, the base graphics system is relatively difficult to extend and limits the complexity of tree figure to be displayed. OutbreakTools (Jombart et al. 2014) and phyloseq (McMurdie and Holmes 2013) extended ggplot2 to plot phylogenetic trees. The ggplot2 system of graphics allows rapid customization and exploration of design solutions. However these packages were designed for epidemiology and microbiome data respectively and did not aim to provide a general solution for tree visualization and annotation. The ggtree package also inherits versatile properties of ggplot2, and more importantly allows constructing complex tree figures by freely combining multiple layers of annotations using the tree associated data imported from different sources (importation using treeio package is detailed in Chapter 2). 4.2 Methods and Materials The ggtree package is designed for annotating phylogenetic trees with their associated data of different types and from various sources. These data could come from users or analysis programs, and might include evolutionary rates, ancestral sequences, etc. that are associated with the taxa from real samples, or with the internal nodes representing hypothetic ancestor strain/species, or with the tree branches indicating evolutionary time courses. For instance, the data could be the geographic positions of the sampled avian influenza viruses (informed by the survey locations) and the ancestral nodes (by phylogeographic inference) in the viral gene tree (Lam et al. 2012). The ggtree supports ggplot2’s graphical language, which allows high level of customization, is intuitive and flexible. It is notable that ggplot2 itself does not provide low-level geometric objects or other support for tree-like structures, and hence ggtree is a useful extension on that regard. Even though the other two phylogenetics-related R packages, OutbreakTools and phyloseq, are developed based on ggplot2, the most valuable part of ggplot2 syntax - adding layers of annotations - is not supported in these packages. For example, if we have plotted a tree without taxa labels, OutbreakTools and phyloseq provide no easy way for general R users, who have little knowledge about the infrastructures of these packages, to add a layer of taxa labels. The ggtree extends ggplot2 to support tree objects by implementing a geometric layer, geom_tree, to support visualizing tree structure. In ggtree, viewing a phylogenetic tree is relatively easy, via the command ggplot(tree_object) + geom_tree() + theme_tree() or ggtree(tree_object) for short. Layers of annotations can be added one by one via the + operator. To facilitate tree visualization, ggtree provides several geometric layers, including geom_treescale for adding legend of tree branch scale (genetic distance, divergence time, etc.), geom_range for displaying uncertainty of branch lengths (confidence interval or range, etc.), geom_tiplab for adding taxa label, geom_tipoint and geom_nodepoint for adding symbols of tips and internal nodes, geom_hilight for highlighting a clade with rectangle, and geom_cladelabel for annotating a selected clade with a bar and text label, etc.. A full list of geometric layers provided by ggtree are summarized in Table 4.1. 4.3 Results 4.3.1 Features The ggtree supports displaying phylogram and cladogram (Figure 4.1) and can visualize a tree with different layouts, including rectangular, slanted, circular, fan, unrooted, time-scale and two-dimensional tree. The ggtree allows tree covariates stored in tree object to be used directly in tree visualization and annotation. These covariates can be meta data of the sampling species/sequences used in the tree, statistical analysis or evolutionary inferences of the tree (e.g. divergence time inferred by BEAST or ancestral sequences inferred by HyPhy, etc.). These numerical or categorical data can be used to color branches or nodes of the tree, displayed on the tree with original values or mapping to different symbols. In ggtree, users can add layers to highlight the selected clades, and to label clades or annotate the tree with symbols of different shapes and colors, etc. (more details in Section 3.3.3). Comparing to other phylogenetic tree visualizing packages, ggtree excels at exploring the tree structure and related data visually. For example, a complex tree figure with several annotation layers can be transferred to a new tree object without step-by-step re-creation. An operator, %&lt;%, was created for such operation - to update a tree figure with a new tree object. Branch length can be re-scaled using other numerical variable (as shown in Figure 3.4 which rescales the tree branches using dN value). Phylogenetic trees can be visually manipulated by collapsing, scaling and rotating clade. Circular and fan layout tree can be rotated by specific angle. Trees structures can be transformed from one layout to another. The groupClade function assigns the branches and nodes under different clades into different groups. Similarly, groupOTU function assigns branches and nodes to different groups based on user-specified groups of operational taxonomic units (OTUs) that are not necessarily within a clade, but can be monophyletic (clade), polyphyletic or paraphyletic. A phylogenetic tree can be annotated by mapping different line type, size, color or shape to the branches or nodes that have been assigned to different groups. Treeio package parses diverse annotation data from different software outputs into S4 phylogenetic data objects. The ggtree mainly utilizes these S4 objects to display and annotate the tree. There are also other R packages that defined S3/S4 classes to store phylogenetic trees with their specific associated data, including phylo4 and phylo4d defined in phylobase package, obkdata defined in OutbreakTools package, and phyloseq defined in phyloseq package. All these tree objects are also supported in ggtree and their specific annotation data can be used to annotate the tree in ggtree. Such compatibility of ggtree facilitates the integration of data and analysis results. 4.3.2 Layouts of phylogenetic tree Viewing phylogenetic with ggtree is quite simple, just pass the tree object to ggtree function. We have developed several types of layouts for tree presentation (Figure 4.1), including rectangular (by default), slanted, circular, fan, unrooted (equal angle and daylight methods), time-scaled and 2-dimensional layouts. Here are examples of visualizing a tree with different layouts: library(ggtree) set.seed(2017-02-16) tree &lt;- rtree(50) ggtree(tree) ggtree(tree, layout=&quot;slanted&quot;) ggtree(tree, layout=&quot;circular&quot;) ggtree(tree, layout=&quot;fan&quot;, open.angle=120) ggtree(tree, layout=&quot;equal_angle&quot;) ggtree(tree, layout=&quot;daylight&quot;) ggtree(tree, branch.length=&#39;none&#39;) ggtree(tree, branch.length=&#39;none&#39;, layout=&#39;circular&#39;) ggtree(tree, layout=&quot;daylight&quot;, branch.length = &#39;none&#39;) Figure 4.1: Tree layouts. Phylogram: rectangular layout (A), slanted layout (B), circular layout (C) and fan layout (D). Unrooted: equal-angle method (E) and daylight method (F). Cladogram: rectangular layout (G), circular layout (H) and unrooted layout (I). Slanted and fan layouts for cladogram are also supported. Phylogram. Layouts of rectangular, slanted, circular and fan are supported to visualize phylogram (by default, with branch length scaled) as demonstrated in Figure 4.1A, B, C and D. Unrooted layout. Unrooted (also called ‘radial’) layout is supported by equal-angle and daylight algorithms, user can specify unrooted layout algorithm by passing “equal_angle” or “daylight” to layout parameter to visualize the tree. Equal-angle method was proposed by Christopher Meacham in PLOTREE, which was incorporated in PHYLIP (Retief 2000). This method starts from the root of the tree and allocates arcs of angle to each subtrees proportional to the number of tips in it. It iterates from root to tips and subdivides the angle allocated to a subtree into angles for its dependent subtrees. This method is fast and was implemented in many software packages. As shown in Figure 4.1E, equal angle method has a drawback that tips are tend to be clustered together and leaving many spaces unused. The daylight method starts from an initial tree built by equal angle and iteratively improves it by successively going to each interior node and swinging subtrees so that the arcs of “daylight” are equal (Figure 4.1F). This method was firstly implemented in PAUP* (Wilgenbusch and Swofford 2003). Cladogram. To visualize cladogram that without branch length scaling and only display the tree structure, branch.length is set to “none” and it works for all types of layouts (Figure 4.1G, H and I). Time-scaled layout. For time-scaled tree, the most recent sampling date must be specified via the mrsd parameter and ggtree will scaled the tree by sampling (tip) and divergence (internal node) time, and a time scale axis will be displayed under the tree by default. beast_file &lt;- system.file(&quot;examples/MCC_FluA_H3.tree&quot;, package=&quot;ggtree&quot;) beast_tree &lt;- read.beast(beast_file) ggtree(beast_tree, mrsd=&quot;2013-01-01&quot;) + theme_tree2() Figure 4.2: Time-scaled layout. The x-axis is the timescale (in units of year). The divergence time was inferred by BEAST using molecular clock model. Two-dimensional tree layout. A two-dimensional tree is a projection of the phylogenetic tree in a space defined by the associated phenotype (numerical or categorical trait, on the y-axis) and tree branch scale (e.g., evolutionary distance, divergent time, on the x-axis). The phenotype can be a measure of certain biological characteristics of the taxa and hypothetical ancestors in the tree. This is a new layout we proposed in ggtree, which is useful to track the virus phenotypes or other behaviors (y-axis) changing with the virus evolution (x-axis). In fact, the analysis of phenotypes or genotypes over evolutionary time have been widely used for study influenza virus evolution (Neher et al. 2016), though such analysis diagrams are not tree-like, i.e., no connection between data points, unlike our two-dimensional tree layout that connect data points with the corresponding tree branches. Therefore, this new layout we provided will make such data analysis easier and more scalable for large sequence data sets of influenza viruses. In this example, we used the previous time-scaled tree of H3 human and swine influenza viruses (Figure 4.2; data published in (Liang et al. 2014)) and scaled the y-axis based on the predicted N-linked glycosylation sites (NLG) for each of the taxon and ancestral sequences of hemagglutinin proteins. The NLG sites were predicted using NetNGlyc 1.0 Server8. To scaled the y-axis, the parameter yscale in the ggtree() function is set to a numerical or categorical variable. If yscale is a categorical variable as in this example, users should specify how the categories are to be mapped to numerical values via the yscale_mapping variables. NAG_file &lt;- system.file(&quot;examples/NAG_inHA1.txt&quot;, package=&quot;ggtree&quot;) NAG.df &lt;- read.table(NAG_file, sep=&quot;\\t&quot;, header=FALSE, stringsAsFactors = FALSE) NAG &lt;- NAG.df[,2] names(NAG) &lt;- NAG.df[,1] ## separate the tree by host species tip &lt;- get.tree(beast_tree)$tip.label beast_tree &lt;- groupOTU(beast_tree, tip[grep(&quot;Swine&quot;, tip)], group_name = &quot;host&quot;) p &lt;- ggtree(beast_tree, aes(color=host), mrsd=&quot;2013-01-01&quot;, yscale = &quot;label&quot;, yscale_mapping = NAG) + theme_classic() + theme(legend.position=&#39;none&#39;) + scale_color_manual(values=c(&quot;blue&quot;, &quot;red&quot;), labels=c(&quot;human&quot;, &quot;swine&quot;)) + ylab(&quot;Number of predicted N-linked glycoslyation sites&quot;) ## (optional) add more annotations to help interpretation p + geom_nodepoint(color=&quot;grey&quot;, size=3, alpha=.8) + geom_rootpoint(color=&quot;black&quot;, size=3) + geom_tippoint(size=3, alpha=.5) + annotate(&quot;point&quot;, 1992, 5.6, size=3, color=&quot;black&quot;) + annotate(&quot;point&quot;, 1992, 5.4, size=3, color=&quot;grey&quot;) + annotate(&quot;point&quot;, 1991.6, 5.2, size=3, color=&quot;blue&quot;) + annotate(&quot;point&quot;, 1992, 5.2, size=3, color=&quot;red&quot;) + annotate(&quot;text&quot;, 1992.3, 5.6, hjust=0, size=4, label=&quot;Root node&quot;) + annotate(&quot;text&quot;, 1992.3, 5.4, hjust=0, size=4, label=&quot;Internal nodes&quot;) + annotate(&quot;text&quot;, 1992.3, 5.2, hjust=0, size=4, label=&quot;Tip nodes (blue: human; red: swine)&quot;) Figure 4.3: Two-dimensional tree layout. The trunk and other branches highlighted in red (for swine) and blue (for human). The x-axis is scaled to the branch length (in units of year) of the time-scaled tree. The y-axis is scaled to the node attribute variable, in this case the number of predicted N-linked glycosylation site (NLG) on the hemagglutinin protein. Colored circles indicate the different types of tree nodes. Note that nodes assigned the same x- (temporal) and y- (NLG) coordinates are superimposed in this representation and appear as one node, which is shaded based on the colors of all the nodes at that point. As shown in Figure 4.3, two-dimensional tree good at visualizing the change of phenotype over the evolution in the phylogenetic tree. In this example, it is shown that H3 gene of human influenza A virus maintained high level of N-linked glycosylation sites (n=8 to 9) over last two decades and dropped significantly to 5 or 6 in a separate viral lineage transmitted to swine populations and established there. It was indeed hypothesized that the human influenza virus with high level of glycosylation on the viral hemagglutinin protein provides better shielding effect to protect the antigenic sites from exposure to the herd immunity, and thus has selective advantage in human populations that maintain high level of herd immunity against the circulating human influenza virus strains. For the viral lineage that newly jumped across the species barrier and transmitted to swine population, the shielding effect of the high-level surface glycan oppositely impose selective disadvantage because the receptor-binding domain may also be shielded which greatly affect the viral fitness of the lineage that newly adapted to a new host species. 4.3.3 Annotation layers The ggtree is designed for more general purpose or specific type of tree visualization and annotation. It supports grammar of graphics implemented in ggplot2 and users can freely visualize/annotate a tree by combining several annotation layers. library(ggtree) treetext = &quot;(((ADH2:0.1[&amp;&amp;NHX:S=human], ADH1:0.11[&amp;&amp;NHX:S=human]): 0.05 [&amp;&amp;NHX:S=primates:D=Y:B=100],ADHY: 0.1[&amp;&amp;NHX:S=nematode],ADHX:0.12 [&amp;&amp;NHX:S=insect]): 0.1[&amp;&amp;NHX:S=metazoa:D=N],(ADH4:0.09[&amp;&amp;NHX:S=yeast], ADH3:0.13[&amp;&amp;NHX:S=yeast], ADH2:0.12[&amp;&amp;NHX:S=yeast], ADH1:0.11[&amp;&amp;NHX:S=yeast]):0.1[&amp;&amp;NHX:S=Fungi])[&amp;&amp;NHX:D=N];&quot; tree &lt;- read.nhx(textConnection(treetext)) ggtree(tree) + geom_tiplab() + geom_label(aes(x=branch, label=S), fill=&#39;lightgreen&#39;) + geom_label(aes(label=D), fill=&#39;steelblue&#39;) + geom_text(aes(label=B), hjust=-.5) Figure 4.4: Annotating tree using grammar of graphics. The NHX tree was annotated using grammar of graphic syntax by combining different layers using + operator. Species information were labelled on the middle of the branches, Duplication events were shown on most recent common ancestor and clade bootstrap value were dispalyed near to it. Here, as an example, we visualized the tree with several layers to display annotation stored in NHX tags, including a layer of geom_tiplab to display tip labels (gene name in this case), a layer using geom_label to show species information (S tag) colored by lightgreen, a layer of duplication event information (D tag) colored by steelblue and another layer using geom_text to show bootstrap value (B tag). Layers defined in ggplot2 can be applied to ggtree directly as demonstrated in Figure 4.4 of using geom_label and geom_text. But ggplot2 does not provide graphic layers that are specific designed for phylogenetic tree annotation. For instance, layers for tip labels, tree branch scale legend, highlight or labeling clade are all unavailable. To make tree annotation more flexible, a number of layers have been implemented in ggtree (Table 4.1), enabling different ways of annotation on various parts/components of a phylogenetic tree. Table 4.1: Geom layers defined in ggtree. Layer Description geom_balance highlights the two direct descendant clades of an internal node geom_cladelabel annotate a clade with bar and text label geom_hilight highlight a clade with rectangle geom_label2 modified version of geom_label, with subsetting supported geom_nodepoint annotate internal nodes with symbolic points geom_point2 modified version of geom_point, with subsetting supported geom_range bar layer to present uncertainty of evolutionary inference geom_rootpoint annotate root node with symbolic point geom_segment2 modified version of geom_segment, with subsetting supported geom_strip annotate associated taxa with bar and (optional) text label geom_taxalink associate two related taxa by linking them with a curve geom_text2 modified version of geom_text, with subsetting supported geom_tiplab layer of tip labels geom_tiplab2 layer of tip labels for circular layout geom_tippoint annotate external nodes with symbolic points geom_tree tree structure layer, with multiple layout supported geom_treescale tree branch scale legend 4.3.4 Tree manipulation The ggtree supports many ways of manipulating the tree visually, including viewing selected clade to explore large tree (Figure 4.5), taxa clustering (Figure 4.8), rotating clade or tree (Figure 4.9B and 4.11), zoom out or collapsing clades (Figure 4.6A and 4.7), etc.. Details tree manipulation functions are summarized in Table 4.2. Table 4.2: Tree manipulation functions. Function Descriptiotn collapse collapse a selecting clade expand expand collapsed clade flip exchange position of 2 clades that share a parent node groupClade grouping clades groupOTU grouping OTUs by tracing back to most recent common ancestor identify interactive tree manipulation rotate rotating a selected clade by 180 degree rotate_tree rotating circular layout tree by specific angle scaleClade zoom in or zoom out selecting clade open_tree convert a tree to fan layout by specific open angle A clade is a monophyletic group that contains a single ancestor and all of its descendants. We can visualize a specific selected clade via the viewClade function as demonstrated in Figure 4.5B. Another similar function is gzoom which plots the tree with selected clade side by side. These two functions are developed to explore large tree. library(ggtree) nwk &lt;- system.file(&quot;extdata&quot;, &quot;sample.nwk&quot;, package=&quot;treeio&quot;) tree &lt;- read.tree(nwk) p &lt;- ggtree(tree) + geom_tiplab() viewClade(p, MRCA(p, tip=c(&quot;I&quot;, &quot;L&quot;))) Figure 4.5: Viewing a selected clade of a tree. An example tree used to demonstrate how ggtree support exploring or manipulating phylogenetic tree visually (A). The ggtree supports visualizing selected clade (B). A clade can be selected by specifying a node number or determined by most recent common ancestor of selected tips. It is a common practice to prune or collapse clades so that certain aspects of a tree can be emphasized. The ggtree supports collapsing selected clades using the collapse function as shown in Figure 4.6A. p2 &lt;- p %&gt;% collapse(node=21) + geom_point2(aes(subset=(node==21)), shape=21, size=5, fill=&#39;green&#39;) p2 &lt;- collapse(p2, node=23) + geom_point2(aes(subset=(node==23)), shape=23, size=5, fill=&#39;red&#39;) print(p2) expand(p2, node=23) %&gt;% expand(node=21) Figure 4.6: Collapsing selected clades and expanding collapsed clades. Clades can be selected to collapse (A) and the collapsed clades can be expanded back (B) if necessary as ggtree stored all information of species relationships. Green and red symbols were displayed on the tree to indicate the collapsed clades. Here two clades were collapsed and labelled by green circle and red square symbolic points. Collapsing is a common strategy to collapse clades that are too large for displaying in full or are not primary interest of the study. In ggtree, we can expand (i.e., uncollapse) the collapsed branches back with expand function to show details of species relationships as demonstrated in Figure 4.6B. The ggtree provides another option to zoom out (or compress) these clades via the scaleClade function. In this way, we retain the topology and branch lengths of compressed clades. This helps to save the space to highlight those clades of primary interest to the study. tree2 &lt;- groupClade(tree, c(17, 21)) p &lt;- ggtree(tree2, aes(color=group)) + scale_color_manual(values=c(&quot;black&quot;, &quot;firebrick&quot;, &quot;steelblue&quot;)) scaleClade(p, node=17, scale=.1) Figure 4.7: Scaling selected clade. Clades can be zoom in (if scale &gt; 1) to highlight or zoom out to save space. If users want to emphasize important clades, they can use scaleClade function with scale parameter larger than 1. Then the selected clade will be zoomed in. Users can also use groupClade to select clades and color them with different colors as shown in Figure 4.7. Although groupClade works fine with clade (monophyletic), related taxa are not necessarily within a clade, they can be polyphyletic or paraphyletic. The ggtree implemented groupOTU to work with polyphyletic and paraphyletic. It accepts a vector of OTUs (taxa name) or a list of OTUs and will trace back from OTUs to their most recent common ancestor (MRCA) and cluster them together as demonstrated in Figure 4.8. tree2 &lt;- groupOTU(tree, focus=c(&quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;)) ggtree(tree2, aes(color=group)) + geom_tiplab() Figure 4.8: Grouping OTUs. OTU clustering based on their relationships. Selected OTUs and their ancestors upto MRCA will be clustered together. To facilitate exploring the tree structure, ggtree supports rotating selected clade by 180 degree using the rotate function (Figure 4.9B). Position of immediate descendant clades of internal node can be exchanged via flip function (Figure 4.9C). p1 &lt;- p + geom_point2(aes(subset=node==16), color=&#39;darkgreen&#39;, size=5) p2 &lt;- rotate(p1, 17) %&gt;% rotate(21) flip(p2, 17, 21) Figure 4.9: Exploring tree structure. A clade (indicated by darkgreen circle) in a tree (A) can be rotated by 180° (B) and the positions of its immediate descedant clades (colored by blue and red) can be exchanged (C). Most of the tree manipulation functions are working on clades, while ggtree also provides functions to manipulate a tree, including open_tree to transform a tree in either rectangular or circular layout to fan layout, and rotate_tree function to rotate a tree for specific angle in both circular or fan layouts, as demonstrated in Figure 4.10 and 4.11. p3 &lt;- open_tree(p, 180) + geom_tiplab2() print(p3) Figure 4.10: Transforming a tree to fan layout. A tree can be transformed to fan layout by open_tree with specific angle parameter. rotate_tree(p3, 180) Figure 4.11: Rotating tree. A circular/fan layout tree can be rotated by any specific angle. 4.3.5 Tree annotation using data from evolutionary analysis software Chapter 2 has introduced using treeio packages to parse different tree formats and commonly used software outputs to obtain phylogeny-associated data. These imported data as S4 objects can be visualized directly using ggtree. Figure 4.4 demonstrates a tree annotated using the information (species classification, duplication event and bootstrap value) stored in NHX file. PHYLODOG and RevBayes output NHX files that can be parsed by treeio and visualized by ggtree with annotation using their inference data. Furthermore, the evolutionary data from the inference of BEAST, MrBayes and RevBayes, dN/dS values inferred by CodeML, ancestral sequences inferred by HyPhy, CodeML or BaseML and short read placement by EPA and pplacer can be used to annotate the tree directly. file &lt;- system.file(&quot;extdata/BEAST&quot;, &quot;beast_mcc.tree&quot;, package=&quot;treeio&quot;) beast &lt;- read.beast(file) ggtree(beast) + geom_tiplab(align=TRUE, linetype=&#39;dashed&#39;, linesize=.3) + geom_range(&quot;length_0.95_HPD&quot;, color=&#39;red&#39;, size=2, alpha=.5) + geom_text2(aes(label=round(as.numeric(posterior), 2), subset=as.numeric(posterior)&gt; 0.9, x=branch), vjust=0) Figure 4.12: Annotating BEAST tree with length_95%_HPD and posterior. Branch length credible intervals (95% HPD) were displayed as red horizontal bars and clade posterior values were shown on the middle of branches. In Figure 4.12, the tree was visualized and annotated with posterior &gt; 0.9 and demonstrated length uncertainty (95% Highest Posterior Density (HPD) interval). Ancestral sequences inferred by HyPhy can be parsed using treeio, whereas the substitutions along each tree branch was automatically computed and stored inside the phylogenetic tree object (i.e., S4 object). The ggtree can utilize this information in the object to annotate the tree, as demonstrated in Figure 4.13. nwk &lt;- system.file(&quot;extdata/HYPHY&quot;, &quot;labelledtree.tree&quot;, package=&quot;treeio&quot;) ancseq &lt;- system.file(&quot;extdata/HYPHY&quot;, &quot;ancseq.nex&quot;, package=&quot;treeio&quot;) tipfas &lt;- system.file(&quot;extdata&quot;, &quot;pa.fas&quot;, package=&quot;treeio&quot;) hy &lt;- read.hyphy(nwk, ancseq, tipfas) ggtree(hy) + geom_text(aes(x=branch, label=AA_subs), size=2, vjust=-.3, color=&quot;firebrick&quot;) Figure 4.13: Annotating tree with amino acid substitution determined by ancestral sequences inferred by HYPHY. Amino acid substitutions were displayed on the middle of branches. PAML’s BaseML and CodeML can be also used to infer ancestral sequences, whereas CodeML can infer selection pressure. After parsing this information using treeio, ggtree can integrate this information into the same tree structure and used for annotation as illustrated in Figure 4.14. rstfile &lt;- system.file(&quot;extdata/PAML_Codeml&quot;, &quot;rst&quot;, package=&quot;treeio&quot;) mlcfile &lt;- system.file(&quot;extdata/PAML_Codeml&quot;, &quot;mlc&quot;, package=&quot;treeio&quot;) ml &lt;- read.codeml(rstfile, mlcfile) ggtree(ml, aes(color=dN_vs_dS), branch.length=&#39;dN_vs_dS&#39;) + scale_color_continuous(name=&#39;dN/dS&#39;, limits=c(0, 1.5), oob=scales::squish, low=&#39;darkgreen&#39;, high=&#39;red&#39;) + geom_text(aes(x=branch, label=joint_AA_subs), vjust=-.5, color=&#39;steelblue&#39;, size=2) + theme_tree2(legend.position=c(.9, .3)) Figure 4.14: Annotating tree with animo acid substitution and dN/dS inferred by CodeML. Branches were rescaled and colored by dN/dS values and amino acid substitutions were displayed on the middle of branches. For more details and examples of annotating tree with evolutionary data inferred by different software packages can be referred to the online vignettes9. 4.3.6 Tree annotation based on tree classes defined in other R packages The ggtree plays a unique role in R ecosystem to facilitate phylogenetic analysis. It serves as a generic tools for tree visualization and annotation with different associated data from various sources. Most of the phylogenetic tree classes defined in R community are supported, including obkData, phyloseq, phylo, multiPhylo, phylo4 and phylo4d. Such that ggtree can be easily integrated into their analysis/packages. For instance, phyloseq users will find ggtree useful for visualizing microbiome data and for further annotations, since ggtree supports high-level of annotation using grammar of graphics and some of its features are not available in phyloseq. Here, examples of using ggtree to annotate obkData and phyloseq tree objects are demonstrated. There example data can be found in vignettes of OutbreakTools (Jombart et al. 2014) and phyloseq (McMurdie and Holmes 2013) packages. The okbData is defined to store incidence-based outbreak data, including meta data of sampling and information of infected individuals such as age and onset of symptoms. The ggtree supports parsing this information which was used to annotate the tree as shown in Figure 4.15. library(OutbreakTools) data(FluH1N1pdm2009) attach(FluH1N1pdm2009) x &lt;- new(&quot;obkData&quot;, individuals = individuals, dna = dna, dna.individualID = samples$individualID, dna.date = samples$date, trees = FluH1N1pdm2009$trees) ggtree(x, mrsd=&quot;2009-09-30&quot;, as.Date=TRUE, right=TRUE) + geom_tippoint(aes(color=location), size=3, alpha=.75) + scale_color_brewer(&quot;location&quot;, palette=&quot;Spectral&quot;) + theme_tree2(legend.position=&#39;right&#39;) Figure 4.15: Visualizing obkData tree object. x-axis was scaled by timeline of the outbreak and tips were colored by location of different individuals. The phyloseq class that defined in the phyloseq package was designed for storing microbiome data, including phylogenetic tree, associated sample data and taxonomy assignment. It can import data from popular pipelines, such as QIIME (Kuczynski et al. 2011), mothur (Schloss et al. 2009), DADA2 (Callahan et al. 2016) and PyroTagger (Kunin and Hugenholtz 2010), etc.. The ggtree supports visualizing the phylogenetic tree stored in phyloseq object and related data can be used to annotate the tree as demonstrated in Figure 4.16. library(phyloseq) library(ggjoy) library(dplyr) library(ggtree) data(&quot;GlobalPatterns&quot;) GP &lt;- GlobalPatterns GP &lt;- prune_taxa(taxa_sums(GP) &gt; 600, GP) sample_data(GP)$human &lt;- get_variable(GP, &quot;SampleType&quot;) %in% c(&quot;Feces&quot;, &quot;Skin&quot;) mergedGP &lt;- merge_samples(GP, &quot;SampleType&quot;) mergedGP &lt;- rarefy_even_depth(mergedGP,rngseed=394582) mergedGP &lt;- tax_glom(mergedGP,&quot;Order&quot;) melt_simple &lt;- psmelt(mergedGP) %&gt;% filter(Abundance &lt; 120) %&gt;% select(OTU, val=Abundance) p &lt;- ggtree(mergedGP) + geom_tippoint(aes(color=Phylum), size=1.5) facet_plot(p, panel=&quot;Abundance&quot;, data=melt_simple, geom_joy, mapping = aes(x=val,group=label, fill=Phylum), color=&#39;grey80&#39;, lwd=.3) Figure 4.16: Visualizing phyloseq tree object. Tips were colored by Phylum and corresponding abundance across different samples were visualized as joyplots and sorted according to the tree structure. 4.3.7 Advanced annotation on the phylogenetic tree The ggtree supports grammar of graphics that implemented in ggplot2 package and provides several layers and functions to facilitate phylogenetic visualization and annotation. These layers and functions are not designed for specific tasks, they are building blocks that can be freely combined together to produce complex tree figure. Previous sessions have introduced some important functions of ggtree. In this session, three examples were presented to demonstrate using various ggtree functions together to construct a complex tree figure with annotations by associated data and inference results from different analysis programs. 4.3.7.1 Example 1: plot curated gene information as heatmap This example introduces annotating a tree with various sources of data (e.g., location, sampling year, curated genotype information, etc.). ## use the following command to get the data from Holt Lab ## git clong https://github.com/katholt/plotTree.git setwd(&quot;plotTree/tree_example_april2015/&quot;) info &lt;- read.csv(&quot;info.csv&quot;) tree &lt;- read.tree(&quot;tree.nwk&quot;) cols &lt;- c(HCMC=&#39;black&#39;, Hue=&#39;purple2&#39;, KH=&#39;skyblue2&#39;) p &lt;- ggtree(tree, layout=&#39;circular&#39;) %&lt;+% info + geom_tippoint(aes(color=location)) + scale_color_manual(values=cols) + geom_tiplab2(aes(label=name), align=T, linetype=NA, size=2, offset=4, hjust=0.5) + geom_tiplab2(aes(label=year), align=T, linetype=NA, size=2, offset=8, hjust=0.5) The tree was visualized in circular layout and attached with the strain sampling location information. A geom_tippoint layer added circular symbolic points to tree tips and colored them by their locations. Two geom_tiplab2 were added to display taxon names and sampling years. heatmapData=read.csv(&quot;res_genes.csv&quot;, row.names=1) rn &lt;- rownames(heatmapData) heatmapData &lt;- as.data.frame(sapply(heatmapData, as.character)) rownames(heatmapData) &lt;- rn heatmap.colours &lt;- c(&quot;white&quot;,&quot;grey&quot;,&quot;seagreen3&quot;,&quot;darkgreen&quot;, &quot;green&quot;,&quot;brown&quot;,&quot;tan&quot;,&quot;red&quot;,&quot;orange&quot;, &quot;pink&quot;,&quot;magenta&quot;,&quot;purple&quot;,&quot;blue&quot;,&quot;skyblue3&quot;, &quot;blue&quot;,&quot;skyblue2&quot;) names(heatmap.colours) &lt;- 0:15 gheatmap(p, heatmapData, offset = 10, color=NULL, colnames_position=&quot;top&quot;, colnames_angle=90, colnames_offset_y = 1, hjust=0, font.size=2) + scale_fill_manual(values=heatmap.colours, breaks=0:15) The curated gene information was further loaded and plotted as a heatmap using gheatmap function with customized colors. The final figure was demonstrated in Figure 4.17. Figure 4.17: Example of annotating a tree with diverse associated data. Circle symbols are colored by strain sampling location. Taxa names and sampling years are aligned to the tips. Curated gene information were visualized as a heatmap (colored boxed on the outer circles). 4.3.7.2 Example 2: complex tree annotations The ggtree allows various evidences inferred by different software to be integrated, compared and visualized on a same tree topology. Data from external files can be further integrated for analysis and visualization. This example introduces complex tree annotations with evolutionary data inferred by different software (BEAST and CodeML in this example) and other associated data (e.g., genotype table). library(treeio) library(ggtree) beast_file &lt;- system.file(&quot;examples/MCC_FluA_H3.tree&quot;, package=&quot;ggtree&quot;) rst_file &lt;- system.file(&quot;examples/rst&quot;, package=&quot;ggtree&quot;) mlc_file &lt;- system.file(&quot;examples/mlc&quot;, package=&quot;ggtree&quot;) beast_tree &lt;- read.beast(beast_file) codeml_tree &lt;- read.codeml(rst_file, mlc_file) merged_tree &lt;- merge_tree(beast_tree, codeml_tree) cols &lt;- scale_color(merged_tree, &quot;dN_vs_dS&quot;, low=&quot;#0072B2&quot;, high=&quot;#D55E00&quot;, interval=seq(0, 1.5, length.out=100)) p &lt;- ggtree(merged_tree, size=.8, mrsd=&quot;2013-01-01&quot;, ndigits = 2, color=cols) p &lt;- add_colorbar(p, cols, font.size=3) p &lt;- p + geom_text(aes(label=posterior), color=&quot;darkgreen&quot;, vjust=-.1, hjust=-.03, size=1.8) First of all, BEAST and CodeML outputs were parsed, and the two trees with the associated data were merged into one. After merging, all statistical data inferred by these software packages, including divergence time and dN/dS will be incorporated into the merged_tree object. The tree was first visualized in time-scale and its branches were colored with dN/dS, and annotated the tree with posterior clade probabilities. site_file &lt;- system.file(&quot;examples/sites.txt&quot;, package=&quot;ggtree&quot;) site &lt;- read.table(site_file)[,1] tree &lt;- mask(merged_tree, &quot;joint_AA_subs&quot;, site, mask_site = FALSE) p &lt;- p + geom_text(aes(x=branch, label=joint_AA_subs), vjust=-.03, size=1.8) The tree branches were further annotated with amino acid substitutions pre-computed from taxon sequences and the ancestral sequences imported from CodeML. tip &lt;- get.tree(merged_tree)$tip.label host &lt;- rep(&quot;Human&quot;, length(tip)) host[grep(&quot;Swine&quot;, tip)] &lt;- &quot;Swine&quot; host.df &lt;- data.frame(taxa=tip, host=factor(host)) p &lt;- p %&lt;+% host.df + geom_tippoint(aes(color=host), size=2) + geom_tiplab(aes(color=host), align=TRUE, size=3, linesize=.3) + scale_color_manual(values = c(&quot;#377EB8&quot;, &quot;#E41A1C&quot;), guide=&#39;none&#39;) Symbolic points were added to tree tips with different colors to differentiate host species of the influenza virus samples (blue for human and red for swine). genotype_file &lt;- system.file(&quot;examples/Genotype.txt&quot;, package=&quot;ggtree&quot;) genotype &lt;- read.table(genotype_file, sep=&quot;\\t&quot;, stringsAsFactor=F) colnames(genotype) &lt;- sub(&quot;\\\\.&quot;, &quot;&quot;, colnames(genotype)) genotype[genotype == &quot;trig&quot;] &lt;- &quot;TRIG&quot; genotype[genotype == &quot;pdm&quot;] &lt;- &quot;Pdm/09&quot; p &lt;- gheatmap(p, genotype, width=.4, offset=7, colnames=F) %&gt;% scale_x_ggtree p + scale_fill_brewer(palette=&quot;Set2&quot;) + theme_tree2() + scale_y_continuous(expand=c(0, 0.6)) + xlab(&quot;Time&quot;) + theme(legend.text=element_text(size=8), legend.key.height=unit(.5, &quot;cm&quot;), legend.key.width=unit(.4, &quot;cm&quot;), legend.position=c(.13, y=.945), axis.text.x=element_text(size=10), axis.title.x = element_text(size=12)) Finally, a genotype table (imported from external file) was plotted as a heatmap and aligned to the tree according to the tree structure as shown in Figure 4.18. Figure 4.18: Example of annotating a tree with evolutionary evidences inferred by different software. The x-axis is the time scale (in units of year) inferred by BEAST. The tree branches are colored by their dN/dS values (as in the left scale at the top) inferred by CodeML, and the internal node labels show the posteria probabilities inferred by BEAST. Tip labels (taxon names) and circles are colored by species (human in blue and swine in red). The genotype, which is shown as an array of colored boxes on the right, is composed of the lineages (either HuH3N2, Pdm/09 or TRIG, colored as in the right legend at the top) of the eight genome segments of the virus. Any missing segment sequences are shown as empty boxes. 4.3.7.3 Example 3: Integrating ggtree in analysis pipeline/workflow In the first example, a tree figure was annotated with external data, whereas second example introduced more complex annotations with evolutionary data inferred by different software and other associated data. This example will demonstrate integrating ggtree to an analysis pipeline that start from nucleotide sequence, building a tree, using R package to inferred ancestral sequences and states, then using ggtree to integrate these inferences to visualize and interpret results to help identify evolutionary patterns. In this example, we collected 1498 H3 sequences (restrict host to Avian only to reduce sequence number for demonstration) with criteria of minimum length of 1000bp (access date: 2016/02/20). H3 sequences were aligned by MUSCLE (Edgar 2004) and the tree was build using RAxML (Stamatakis 2014) with GTRGAMMA model. Ancestral sequences were estimated by phangorn (Schliep 2011). library(phangorn) library(ggtree) treefile &lt;- &quot;RAxML_bestTree.Aln_All_H3.nwk&quot; tipseqfile &lt;- &quot;Aln_All_H3_filted.fas&quot; tre &lt;- read.tree(treefile) tre2 &lt;- midpoint(as.binary(tre)) tipseq &lt;- read.phyDat(tipseqfile, format = &quot;fasta&quot;) fit &lt;- pml(tre2, tipseq, k = 4) fit &lt;- optim.pml(fit, optNni = FALSE, optBf = TRUE, optQ = TRUE, optInv = TRUE, optGamma = TURE, optEdge = FALSE, optRooted = FALSE, model = &quot;GTR&quot;) phangorn &lt;- phyPML(fit, type = &quot;joint&quot;) The pml function computed the likelihood of the tree given the sequence alignment and optim.pml function optimized different parameters under the GTR model. The function phyPML, implemented in treeio, collected ancestral sequences inferred by optim.pml and determined amino acid sustitution by comparing parent sequence to child sequence. host &lt;- sub(&quot;\\\\w+\\\\|A/([A-Za-z_\\\\-]+)/.*&quot;, &quot;\\\\1&quot;, phangorn@phylo$tip.label) %&gt;% gsub(&quot;-&quot;, &quot;_&quot;, .) %&gt;% tolower %&gt;% gsub(&quot;.*_(\\\\w+)$&quot;, &quot;\\\\1&quot;, .) names(host) &lt;- phangorn@phylo$tip.label host_inf &lt;- ace(host, phangorn@phylo, type=&quot;discrete&quot;, method=&quot;ML&quot;) i &lt;- apply(host_inf$lik.anc, 1, which.max) host.df &lt;- data.frame(node=1:Nnode(phangorn@phylo, internal.only=F), host=c(host, sort(unique(host))[i])) phangorn@extraInfo &lt;- host.df ggtree(phangorn) + geom_point(aes(color=host)) + theme(legend.position=c(.25, .85)) Host information was extracted from taxa name and ancestral hosts were estimated by ace function defined in ape package (Paradis, Claude, and Strimmer 2004) using maximum likelihood. Then using ggtree was used to visualize circles colored by the host information. Figure 4.19: Example of integrating ggtree in analysis pipeline. A phylogenetic tree of H3 influenza viruses built by RAxML. Ancestral sequences were inferred by phangorn and ancestral host information estimated by ape. The ggtree allows integrating information for visualization and further analysis. The tree was annotated by symbolic circles colored by host information as in the legend at top right. The ggtree can be integrated into analysis pipeline as demonstrated in this example and allows different diverse data sources to be combined into a tree object. As illustrated in this example, host information and ancestral sequences were stored in the tree object. Thereafter ggtree allows further comparison and analysis. For instance, users can associate amino acid substitution with host jump as demonstrated in Figure 4.20. Some sites (around position of 400) are conservative across different species and some sites (around position of 20) are frequently mutated especially for host jump to mallard (Figure 4.20A). Interestingly, mutations co-occurred with chicken-to-duck transmission tend to cluster in the HA global head; whereas the mutations distributed over the cytoplasmic tail of the HA are often leading to mallard transmission especially for teal-to-mallard and duck-to-mallard transmissions (Figure 4.20B). These results could direct the further experimental investigations of these markers, such as through reverse genetic studies. Figure 4.20: Amino acid substitution preferences. Different locations have different mutation frequencies. Mutations that lead to host jump have different preferences on mutation sites. 4.3.8 Performance comparison with other tree-related packages Visualization and annotation of phylogenetic trees are possible thanks to many different packages. Especially in ape (Paradis, Claude, and Strimmer 2004) and phytools (Revell 2012), which provide many features of tree manipulation and visualization in base plotting system. The ggtree package brings various capabilities of phylogenetic visualization and annotation to the ggplot2 plotting system with high level of customizability possible thanks to the object-oriented approach of graphic and data communication. OutbreakTools (Jombart et al. 2014) and phyloseq (McMurdie and Holmes 2013) also implemented tree view functions using ggplot2 for presenting data from epidemiology and microbiome respectively. A comprehensive comparison of different features available in these packages can be found in Table ??. Here I present the benchmark performance of these packages. A random tree with 1000 leaves were used for basic tree visualization as shown in Figure 4.21. Basically ggtree and phyloseq are two most robust and fastest packages for viewing phylogenetic trees. Figure 4.21: Run time comparison for basic tree visualization. Tree topology visualization with/without taxa name. OutbreakTooks and phyloseq defined their own classes to store tree objects and specific data from epidemiology and microbiome respectively. OutbreakTools only works with obkData objects, while phyloseq works with phylo and phyloseq objects. As OutbreakTools cannot view phylo object, it was not incorporated in run time comparison of viewing phylogenetic trees. Although phyloseq can view phylo object, it lacks capability of annotating a phylogenetic tree with user data. To compare the performance of phylogenetic tree annotation, here I used ape and ggtree to reproduce examples presented in OutbreakTools and phyloseq vignettes. Noteably, S4 classes including obkData and phylose defined in OutbreakTools and phyloseq are also supported by ggtree and users can use + operator to add related annotation layers. As demonstrated in Figure 4.22, ape is the fastest package for tree annotation and ggtree outperform phyloseq and OutbreakTools. Figure 4.22: Run Time comparison for tree annotation. Reproducing tree annotation example of OutbreakTools and phyloseq using ape and ggtree. To further compare visualizing phylogenetic trees with different numbers of leaves, here I used random trees with leaves ranging from 10 to 1000 with step by 10. As illustrated in Figure 4.23, ape and phytools are faster when trees are small while ggtree and phyloseq perform better with large tree. Figure 4.23: Run time of viewing tree with different numbers of leaves. The slowest time to view a phylogenetic tree with 1000 leaves is only 1 second. All these tools are fast enough for ordinary usages. The benchmark was performed on iMac 3.2G Intel Core i5 with 16GB memory running OS X EI Capitan. Source code to reproduce benchmark results are presented in Figure ??, ??, ?? and ??. In the speed tests of ggtree and other packages using small to moderate size, ape and phytools are faster than ggtree and phyloseq. While for large tree, ggtree and phyloseq is faster than ape and phytools. For simple tree without annotation, phyloseq is faster than ggtree, while when annotating tree with multiple layers, ggtree is more efficient than both OutbreakTools and phyloseq. In addition, ggtree is a general tools that designed for tree annotation, while OutbreakTools and phyloseq are implemented for specific domain that lack of many features for general purpose of tree annotation. ggtree also provide grammar of graphic that are intuitive, easy to learn and allows high level of customization that are not available in other packages. In general, the performance of ggtree is more stable with different size of trees and different layers of annotation. The ggtree run fast in most of the tree visualization and annotation problems especially excels at large tree visualization and complex tree annotation. 4.4 Discussion Creating a tree figure annotated with associated information (from experimental analyses, evolutionary inferences, etc.) is an important part of research on molecular evolution. Most of the tree viewing software lack the utilities to incorporate data from multiple external sources or by parsing files generated by other analysis programs/packages. FigTree is one of the commonly used software for tree visualization and annotation, whereas it mainly supports parsing BEAST output and not from other tools to annotate the tree. FigTree is a typical viewer in this field that designed for specific data type and implemented pre-defined annotation for specific needs. Tools for visualizing phylogenetic trees are proliferating. Producing a publication-ready informative tree figure typically involves a series of annotation steps and requires several software packages to generate a static image as an end product. Such static image doesn’t contain choices of selecting features (e.g. ancestral state) that used to render the tree (e.g. as text label or branch width). This process is often one-way that has no route to return to previous annotation steps. It is often difficult to modify or reuse the underlying annotation information in other contexts (e.g., add a new layer of clade support value on the same tree). Therefore, repeated creations of similar complex tree figures for analysis or publication become extremely time-consuming. Existing workflows are suboptimal from the standpoint of sharing and reuse. Tree visualization and annotation should contain a serialize compositions that preserve the selection and annotation in a portable format. This format can be modified (e.g., change color, add new layer etc.) and rendering the tree with annotation when needed. This way will make tree annotation more portable and transparent. The ggtree is designed to solve these issues. It can utilize evolutionary data from different tree objects (e.g., those parsed by treeio, see Chapter 2) as well as import other associated experimental data from external files, so that various sources and types of data can be displayed on a tree for comparison and further analyses. The ggtree also supports visualization of tree objects defined by other R packages so that ggtree can be easily integrated into existing analysis pipelines. For example, phyloseq tree object is supported by ggtree and microbiome data can be used to annotate the tree using ggtree. The ggtree extends ggplot2 graphic system and allows creating separate geometric layers that can be freely combined, removed and rearranged to support diverse but convenient ways of tree manipulation and visualization. Layers defined in ggtree are not for specific purpose but serve as building blocks to annotate trees to meet users’ own needs in their favorite way. The ggtree generates an image file of tree figures when users render the output object to an image file. Instead of producing an image file that can hardly be modified and reused, ggtree outputs a ggtree object that contains a serialized data that preserve the tree and associated data with layers of different data for tree tree annotation. These data (including tree, annotation data and layers) can be manipulated to modify tree, reuse data and adding/modifying layers of tree annotation. The ggtree fits the ecosystem of R community as it supports most of the tree objects defined by the community and can be easily integrated to existing workflows. It also works with other packages to enhance its interoperability, for example, ggtree works with ggbio (Yin, Cook, and Lawrence 2012) package to visualize phylogenetic tree with genomic features and works with ggseqlogo10 package to annotate phylogenetic tree with sequence logo (Figure ??). Using ggtree, large phylogenetic tree figures with complex annotations can be more easily and consistently generated. This is particular useful for those studying the virus genome and evolution. The recent rise of the field ‘phylodynamics’ has been widely applied in influenza research, and many studies in literature were trying to identify the association between the dynamic virus phenotypes and evolution (Loverdo and Lloyd-Smith 2013, Koelle et al. (2006)). Our ggtree could become an essential platform for high-level analysis of the data resulting from different types of evolutionary analyses. References "],
["chapter-ggimage.html", "Chapter 5 Annotating phylogenetic tree with images 5.1 Annotate tips 5.2 Annotate internal nodes 5.3 Use image as background", " Chapter 5 Annotating phylogenetic tree with images 5.1 Annotate tips library(ggimage) library(ggtree) url &lt;- paste0(&quot;https://raw.githubusercontent.com/TreeViz/&quot;, &quot;metastyle/master/design/viz_targets_exercise/&quot;) x &lt;- read.tree(paste0(url, &quot;tree_boots.nwk&quot;)) info &lt;- read.csv(paste0(url, &quot;tip_data.csv&quot;)) p &lt;- ggtree(x) %&lt;+% info + xlim(NA, 6) p + geom_tiplab(aes(image= imageURL), geom=&quot;image&quot;, offset=2, align=T, size=.16, hjust=0) + geom_tiplab(geom=&quot;label&quot;, offset=1, hjust=.5) 5.2 Annotate internal nodes ## example from https://rgriff23.github.io/2017/05/11/primate-phylogeny-ggtree.html library(ape) tree &lt;- read.nexus(&quot;https://raw.githubusercontent.com/rgriff23/Dissertation/master/Chapter_2/data/tree.nex&quot;) phylopic_info &lt;- data.frame(node = c(124, 113, 110, 96, 89, 70), phylopic = c(&quot;7fb9bea8-e758-4986-afb2-95a2c3bf983d&quot;, &quot;bac25f49-97a4-4aec-beb6-f542158ebd23&quot;, &quot;f598fb39-facf-43ea-a576-1861304b2fe4&quot;, &quot;aceb287d-84cf-46f1-868c-4797c4ac54a8&quot;, &quot;0174801d-15a6-4668-bfe0-4c421fbe51e8&quot;, &quot;72f2f854-f3cd-4666-887c-35d5c256ab0f&quot;), species = c(&quot;galagoids&quot;, &quot;lemurs&quot;, &quot;tarsiers&quot;, &quot;cebids&quot;, &quot;hominoids&quot;, &quot;cercopithecoids&quot;)) pg &lt;- ggtree(tree) pg %&lt;+% phylopic_info + geom_nodelab(aes(image=phylopic), geom=&quot;phylopic&quot;, alpha=.5, color=&#39;steelblue&#39;) d &lt;- data.frame(node = c(&quot;70&quot;,&quot;89&quot;,&quot;96&quot;,&quot;110&quot;,&quot;113&quot;,&quot;124&quot;), images = c(&quot;https://i.imgur.com/8VA9cYw.png&quot;, &quot;https://i.imgur.com/XYM1T2x.png&quot;, &quot;https://i.imgur.com/EQs5ZZe.png&quot;, &quot;https://i.imgur.com/2xin0UK.png&quot;, &quot;https://i.imgur.com/hbftayl.png&quot;, &quot;https://i.imgur.com/3wDHW8n.png&quot;)) pg %&lt;+% d + geom_nodelab(aes(image=images), geom=&quot;image&quot;, alpha=0.5) 5.3 Use image as background pg + geom_phylopic(image=&quot;79ad5f09-cf21-4c89-8e7d-0c82a00ce728&quot;, size=Inf, alpha=.5, color=&#39;firebrick&#39;) "],
["references.html", "References", " References "]
]
